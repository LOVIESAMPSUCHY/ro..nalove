<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8">
  <title>suchybuild</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
    canvas { display: block; }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      background: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 5px;
    }
    #startMenu {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 20px;
      border-radius: 10px;
      text-align: center;
    }
    #startMenu button {
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <!-- Interfejs użytkownika -->
  <div id="ui">
    <div>Wysokość: <span id="altitude">0</span> m</div>
    <div>Prędkość: <span id="speed">0</span> m/s</div>
  </div>
  <div id="startMenu">
    <h1>RocketBysuchy</h1>
    <p>Naciśnij "Start", aby rozpocząć misję!</p>
    <button id="startButton">Start</button>
  </div>

  <!-- Ładowanie biblioteki Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
  <script>
    // Inicjalizacja zmiennych globalnych
    let scene, camera, renderer, rocket, particleSystem, earth, satellites = [], asteroids = [];
    let gameStarted = false;
    let velocity = new THREE.Vector3(0, 0, 0);
    const gravity = -0.002; // Grawitacja działa w dół
    const maxSpeed = 0.5; // Maksymalna prędkość rakiety
    const thrust = 0.02; // Siła ciągu silników

    // Inicjalizacja sceny, kamery i renderera
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(0, 8, 15);

    renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Dodanie oświetlenia
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);

    const pointLight = new THREE.PointLight(0xffffff, 1);
    pointLight.position.set(5, 5, 5);
    scene.add(pointLight);

    // Dodanie ziemi jako płaszczyzny
    const groundGeometry = new THREE.PlaneGeometry(200, 200);
    const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = 0;
    scene.add(ground);

    // Funkcja tworząca rakietę SpaceX
    function createSpaceXRocket() {
      const rocket = new THREE.Group();
      
      // 1. Dolny stopień – główny kadłub
      const lowerStageGeometry = new THREE.CylinderGeometry(0.5, 0.5, 6, 32);
      const lowerStageMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
      const lowerStage = new THREE.Mesh(lowerStageGeometry, lowerStageMaterial);
      rocket.add(lowerStage);
      
      // 2. Czerwony pasek ozdobny
      const stripeGeometry = new THREE.CylinderGeometry(0.51, 0.51, 0.7, 32);
      const stripeMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
      const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
      stripe.position.y = 0;
      rocket.add(stripe);
      
      // 3. Górny stopień – nosówka
      const noseConeGeometry = new THREE.ConeGeometry(0.5, 2, 32);
      const noseConeMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
      const noseCone = new THREE.Mesh(noseConeGeometry, noseConeMaterial);
      noseCone.position.y = 4;
      rocket.add(noseCone);
      
      // 4. Nogi lądowe
      const legGeometry = new THREE.BoxGeometry(0.1, 1, 0.1);
      const legMaterial = new THREE.MeshStandardMaterial({ color: 0x888888 });
      const legRadius = 0.7;
      const legAngles = [45, 135, 225, 315];
      legAngles.forEach(angleDeg => {
        const angleRad = angleDeg * Math.PI / 180;
        const leg = new THREE.Mesh(legGeometry, legMaterial);
        leg.position.x = legRadius * Math.cos(angleRad);
        leg.position.z = legRadius * Math.sin(angleRad);
        leg.position.y = -3.5;
        leg.rotation.z = angleRad;
        rocket.add(leg);
      });
      
      // 5. Silniki
      for (let i = 0; i < 9; i++) {
        const engineGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.3, 16);
        const engineMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
        const engine = new THREE.Mesh(engineGeometry, engineMaterial);
        const engineAngle = i * (2 * Math.PI / 9);
        engine.position.y = -3 - 0.15;
        const engineRadius = 0.35;
        engine.position.x = engineRadius * Math.cos(engineAngle);
        engine.position.z = engineRadius * Math.sin(engineAngle);
        rocket.add(engine);
      }
      
      return rocket;
    }

    // Utworzenie rakiety
    rocket = createSpaceXRocket();
    rocket.position.y = 3.5;
    scene.add(rocket);

    // Funkcja tworząca gwiazdy
    function createStars() {
      const starGeometry = new THREE.SphereGeometry(0.05, 24, 24);
      const starMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
      for (let i = 0; i < 500; i++) {
        const star = new THREE.Mesh(starGeometry, starMaterial);
        star.position.set(
          (Math.random() - 0.5) * 200,
          (Math.random() - 0.5) * 200,
          (Math.random() - 0.5) * 200
        );
        scene.add(star);
      }
    }
    createStars();

    // Dodanie Ziemi jako kuli w tle
    function createEarth() {
      const earthGeometry = new THREE.SphereGeometry(50, 32, 32);
      const earthMaterial = new THREE.MeshStandardMaterial({ color: 0x0066cc });
      earth = new THREE.Mesh(earthGeometry, earthMaterial);
      earth.position.set(0, -150, -100);
      scene.add(earth);
    }
    createEarth();

    // Funkcja tworząca satelity
    function createSatellites() {
      const satelliteGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
      const satelliteMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
      for (let i = 0; i < 5; i++) {
        const satellite = new THREE.Mesh(satelliteGeometry, satelliteMaterial);
        satellite.position.set(
          (Math.random() - 0.5) * 100,
          50 + Math.random() * 50,
          (Math.random() - 0.5) * 100
        );
        satellites.push(satellite);
        scene.add(satellite);
      }
    }
    createSatellites();

    // Funkcja tworząca asteroidy
    function createAsteroids() {
      const asteroidGeometry = new THREE.SphereGeometry(0.5, 8, 8);
      const asteroidMaterial = new THREE.MeshStandardMaterial({ color: 0x888888 });
      for (let i = 0; i < 10; i++) {
        const asteroid = new THREE.Mesh(asteroidGeometry, asteroidMaterial);
        asteroid.position.set(
          (Math.random() - 0.5) * 150,
          60 + Math.random() * 40,
          (Math.random() - 0.5) * 150
        );
        asteroids.push(asteroid);
        scene.add(asteroid);
      }
    }
    createAsteroids();

    // Funkcja tworząca efekty cząsteczkowe (dym i ogień)
    function createParticleSystem() {
      const particleGeometry = new THREE.BufferGeometry();
      const particleCount = 1000;
      const positions = new Float32Array(particleCount * 3);
      const colors = new Float32Array(particleCount * 3);
      const sizes = new Float32Array(particleCount);

      for (let i = 0; i < particleCount; i++) {
        positions[i * 3] = 0;
        positions[i * 3 + 1] = -3.5;
        positions[i * 3 + 2] = 0;
        colors[i * 3] = Math.random(); // Kolor czerwony
        colors[i * 3 + 1] = Math.random() * 0.5; // Kolor zielony
        colors[i * 3 + 2] = 0; // Kolor niebieski
        sizes[i] = Math.random() * 5 + 2;
      }

      particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

      const particleMaterial = new THREE.PointsMaterial({
        vertexColors: true,
        size: 2,
        transparent: true,
        opacity: 0.8,
      });

      particleSystem = new THREE.Points(particleGeometry, particleMaterial);
      rocket.add(particleSystem);
    }
    createParticleSystem();

    // Obsługa sterowania klawiaturą
    const keysPressed = {};
    document.addEventListener('keydown', (event) => {
      keysPressed[event.key] = true;
    });
    document.addEventListener('keyup', (event) => {
      keysPressed[event.key] = false;
    });

    // Funkcja aktualizująca sterowanie rakiety
    function updateRocketControls() {
      if (!gameStarted) return;

      // Obrót rakiety
      if (keysPressed['ArrowLeft']) {
        rocket.rotation.z += 0.05;
      }
      if (keysPressed['ArrowRight']) {
        rocket.rotation.z -= 0.05;
      }

      // Przyspieszenie rakiety (ciąg silników)
      if (keysPressed['ArrowUp']) {
        velocity.y += Math.cos(rocket.rotation.z) * thrust;
        velocity.x -= Math.sin(rocket.rotation.z) * thrust;
      }

      // Grawitacja
      velocity.y += gravity;

      // Ograniczenie prędkości
      velocity.clampScalar(-maxSpeed, maxSpeed);

      // Aktualizacja pozycji rakiety
      rocket.position.add(velocity);

      // Aktualizacja efektów cząsteczkowych
      const positions = particleSystem.geometry.attributes.position.array;
      for (let i = 0; i < positions.length; i += 3) {
        positions[i + 1] -= 0.1; // Symulacja ruchu cząsteczek w dół
        if (positions[i + 1] < -4) {
          positions[i + 1] = -3.5; // Reset pozycji cząsteczek
        }
      }
      particleSystem.geometry.attributes.position.needsUpdate = true;
    }

    // Funkcja aktualizująca interfejs użytkownika
    function updateUI() {
      const altitude = Math.max(0, rocket.position.y - 3.5).toFixed(2);
      const speed = velocity.length().toFixed(2);
      document.getElementById('altitude').textContent = altitude;
      document.getElementById('speed').textContent = speed;
    }

    // Funkcja obsługująca kolizje z obiektami
    function checkCollisions() {
      const rocketBox = new THREE.Box3().setFromObject(rocket);
      satellites.forEach(satellite => {
        const satelliteBox = new THREE.Box3().setFromObject(satellite);
        if (rocketBox.intersectsBox(satelliteBox)) {
          console.log('Kolizja z satelitą!');c
          // Tutaj można dodać efekt eksplozji lub zakończenie gry
        }
      });
      asteroids.forEach(asteroid => {
        const asteroidBox = new THREE.Box3().setFromObject(asteroid);
        if (rocketBox.intersectsBox(asteroidBox)) {
          console.log('Kolizja z asteroidą!');
        }
      });
    }

    // Główna pętla animacji
    function animate() {
      requestAnimationFrame(animate);
      if (gameStarted) {
        updateRocketControls();
        updateUI();
        checkCollisions();

        // Kamera podąża za rakietą
        camera.position.y = rocket.position.y + 8;
        camera.position.x = rocket.position.x;
        camera.lookAt(rocket.position);
      }

      renderer.render(scene, camera);
    }
    animate();

    // Funkcja startu gry
    function startGame() {
      gameStarted = true;
      document.getElementById('startMenu').style.display = 'none';

      // Odtwarzanie dźwięku startu (wymaga pliku audio)
      const audio = new Audio('rocket_launch.mp3');
      audio.play();
    }

    // Obsługa przycisku startu
    document.getElementById('startButton').addEventListener('click', startGame);

    // Obsługa zmiany rozmiaru okna
    window.addEventListener('resize', function() {
      const width = window.innerWidth;
      const height = window.innerHeight;
      renderer.setSize(width, height);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
    });
  </script>
</body>
</html>